<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>2025 on LLP2333&#39;s Blog</title>
    <link>https://qvqw.date/archives/2025/</link>
    <description>Recent content in 2025 on LLP2333&#39;s Blog</description>
    <image>
      <title>LLP2333&#39;s Blog</title>
      <url>https://qvqw.date/images/papermod-cover.png</url>
      <link>https://qvqw.date/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.115.4</generator>
    <language>en</language>
    <lastBuildDate>Tue, 21 Jan 2025 09:12:14 +0800</lastBuildDate>
    <atom:link href="https://qvqw.date/archives/2025/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Cloudflare WARP 解锁Chatgpt</title>
      <link>https://qvqw.date/posts/%E4%BD%BF%E7%94%A8clouflare-warp-%E8%A7%A3%E9%94%81chatgpt/</link>
      <pubDate>Tue, 21 Jan 2025 09:12:14 +0800</pubDate>
      <guid>https://qvqw.date/posts/%E4%BD%BF%E7%94%A8clouflare-warp-%E8%A7%A3%E9%94%81chatgpt/</guid>
      <description>Chatgpt对ip有较为严格的限制，使用Cloudflare WARP可以隐藏服务器的真实ip，解除访问限制。
安装Cloudflare WARP 官方文档
# Add cloudflare gpg key curl -fsSL https://pkg.cloudflareclient.com/pubkey.gpg | sudo gpg --yes --dearmor --output /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg # Add this repo to your apt repositories echo &amp;#34;deb [signed-by=/usr/share/keyrings/cloudflare-warp-archive-keyring.gpg] https://pkg.cloudflareclient.com/ $(lsb_release -cs) main&amp;#34; | sudo tee /etc/apt/sources.list.d/cloudflare-client.list # Install sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install cloudflare-warp 设置cloudflare warp 一定要把mode设置为proxy,然后连接。否则将无法使用ssh访问服务器。
warp-cli registration new #注册 warp-cli mode proxy # 设置代理模式为socks代理 warp-cli proxy port 40000 #设置代理端口40000 warp-cli connect # 连接 xray配置 inbounds 要开启 sniffing</description>
    </item>
    <item>
      <title>使用sni 代理解决服务器无法直接联网的问题</title>
      <link>https://qvqw.date/posts/%E4%BD%BF%E7%94%A8sni-%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 20 Jan 2025 10:41:12 +0800</pubDate>
      <guid>https://qvqw.date/posts/%E4%BD%BF%E7%94%A8sni-%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>正式系统无法访问外网，测试系统可以访问外网。正式系统的一个SDK需要向外网发送HTTP请求，考虑使用sni 代理。
软件 gost [参考文档]{https://gost.run/tutorials/protocols/sni/}
部署 能联网的测试机使用docker compose部署（设置xxx.com的sni代理白名单，xxx.com前面的~表示白名单，不加~表示黑名单） services: gost: image: gogost/gost container_name: gost ports: - &amp;#34;80:80&amp;#34; command: -L sni://:80?bypass=~xxx.com restart: unless-stopped 不能联网的正式机配置/etc/hosts 测试机ip xxx.com 我的后端是容器部署的，然后给容器配置/etc/hosts文件映射就可以了
注意 不能在构建docker image时候修改hosts，只能在容器运行时进行映射或者修改。因为构建阶段/etc/hosts是只读的。image是许多只读layer的叠加，而容器是只读layer和可读layer的叠加</description>
    </item>
    <item>
      <title>使用AspectJ拦截第三方SDK请求</title>
      <link>https://qvqw.date/posts/%E4%BD%BF%E7%94%A8aspectj%E6%8B%A6%E6%88%AA%E7%AC%AC%E4%B8%89%E6%96%B9sdk%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Fri, 10 Jan 2025 13:42:02 +0800</pubDate>
      <guid>https://qvqw.date/posts/%E4%BD%BF%E7%94%A8aspectj%E6%8B%A6%E6%88%AA%E7%AC%AC%E4%B8%89%E6%96%B9sdk%E8%AF%B7%E6%B1%82/</guid>
      <description>最近使用一个第三方的SDK来请求数据，但是请求的服务器对ip有白名单限制，SDK使用的apache的commons-httpclient: 3.1
发送请求。于是尝试使用ApectJ运行时织入，拦截发送HTTP请求的代码，修改参数.
依赖(用的1.9.19版本) &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjrt&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; maven插件 &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectj-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; 切面 import org.apache.commons.httpclient.HttpMethod; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.stereotype.Component; @Aspect @Component public class HttpClientAspect { public static HttpClientAspect aspectOf() { return new HttpClientAspect(); } @Around(&amp;#34;execution(* org.apache.commons.httpclient.HttpClient.executeMethod(..))&amp;#34;) public Object aroundHttpExecution(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(&amp;#34;======================================&amp;#34;); Object[] args = joinPoint.getArgs(); // 获取HttpMethod参数 if (args != null &amp;amp;&amp;amp; args.</description>
    </item>
    <item>
      <title>Java的ResourceBundle读取配置文件路径</title>
      <link>https://qvqw.date/posts/java%E7%9A%84resourcebundle%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 08 Jan 2025 16:06:02 +0800</pubDate>
      <guid>https://qvqw.date/posts/java%E7%9A%84resourcebundle%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</guid>
      <description>当你使用
// 1. 创建或加载 ResourceBundle ResourceBundle bundle = ResourceBundle.getBundle(&amp;#34;messages&amp;#34;); // 从 classpath 加载 messages.properties // 2. 使用getString()获取字符串值 String value = bundle.getString(&amp;#34;key.name&amp;#34;); 读取文件时 代码默认会读取src/main/resources/messages.properties
src/main/resources/messages.properties // 默认 src/main/resources/messages_zh.properties // 中文 src/main/resources/messages_en.properties // 英文 样例配置文件
key.name=值 welcome.message=欢迎 error.code=500 如果想指定读取的文件
// 指定英文 Locale Locale enLocale = new Locale(&amp;#34;en&amp;#34;); // 或者直接用 Locale.ENGLISH // 加载英文资源包 ResourceBundle bundle = ResourceBundle.getBundle(&amp;#34;messages&amp;#34;, enLocale); // 获取英文值 String value = bundle.getString(&amp;#34;key.name&amp;#34;); </description>
    </item>
    <item>
      <title>某云办公应用api存在IP白名单绕过风险</title>
      <link>https://qvqw.date/posts/%E6%9F%90%E4%BA%91%E5%8A%9E%E5%85%AC%E5%BA%94%E7%94%A8api%E5%AD%98%E5%9C%A8ip%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87%E9%A3%8E%E9%99%A9/</link>
      <pubDate>Wed, 08 Jan 2025 10:14:16 +0800</pubDate>
      <guid>https://qvqw.date/posts/%E6%9F%90%E4%BA%91%E5%8A%9E%E5%85%AC%E5%BA%94%E7%94%A8api%E5%AD%98%E5%9C%A8ip%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87%E9%A3%8E%E9%99%A9/</guid>
      <description>最近在做一个消息推送企业某信的需求，使用的不是官方的api,而是和企业某信可以集成的云办公平台的api。由于api有ip白名单限制，导致我必须在特定化网络环境下发请求，测试很麻烦，所以想测试一下能不能绕过限制。 想要绕过限制，首先要知道服务器如何获取发送者的ip。
服务器如何获取请求者ip 获取请求者 IP 本质上就两个来源：
直接从 IP 数据包获取 这就是 HttpServletRequest的getRemoteAddr() 的工作原理，获取的是直接与服务器建立 TCP 连接的客户端 IP，在没有代理的情况下,这就是真实的客户端 IP 从 HTTP 请求头获取 常见的请求头有: X-Forwarded-For X-Real-IP Proxy-Client-IP WL-Proxy-Client-IP 测试 这里我使用了postman伪造了请求头X-Forwarded-For，经过测试，理论上只要知道正确的ip，就可以让ip白名单功能失效。
如果你有服务器的访问权限，但是只知道服务器的内网ip，可以尝试
curl ifconfig.me 然后就能得到服务器的公网ip了
安全建议 改用网络层的源IP地址(TCP/IP报文中的source IP)进行验证
如果必须使用代理转发,建议只信任内部代理服务器传递的XFF头
吐槽 某云办公平台必须付费才能获得访问api的密钥，并且密钥只有一个，测试只能直接在正式系统测</description>
    </item>
    <item>
      <title>用go写了个简化hugo文章创建的小工具</title>
      <link>https://qvqw.date/posts/%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AA%E7%AE%80%E5%8C%96hugo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 07 Jan 2025 14:11:52 +0800</pubDate>
      <guid>https://qvqw.date/posts/%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AA%E7%AE%80%E5%8C%96hugo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>目前使用hugo作为博客系统，使用typora作为博客的编辑器。书接上文Hugo使用技巧，之前每次都需要在博客根目录执行
hugo new posts/文章标题/index.md 创建新的文章。感觉很麻烦。所以想写个工具简化这个过程。
思路 输入文件标题后执行创建文章的命令，然后生成新的文章的快捷方式，方便使用typora进行编辑。
代码 使用Claude生成的，很方便。
如果是windows平台，使用
go build -o HugoHelper.exe main.go 进行编译。
使用前需要配置blog环境变量，key为blog,value为你的项目的根路径
比如我的根目录是C:\UGit\qvqw.date
代码
package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/exec&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;strings&amp;#34; ) func main() { // 获取当前程序执行路径 execPath, err := os.Getwd() if err != nil { fmt.Printf(&amp;#34;错误: 获取当前路径失败: %v\n&amp;#34;, err) os.Exit(1) } // 从环境变量获取博客路径 blogPath := os.Getenv(&amp;#34;blog&amp;#34;) if blogPath == &amp;#34;&amp;#34; { fmt.Println(&amp;#34;错误: 环境变量 &amp;#39;blog&amp;#39; 未设置&amp;#34;) os.Exit(1) } // 验证博客路径是否存在 if _, err := os.</description>
    </item>
  </channel>
</rss>
