<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>2025 on LLP2333&#39;s Blog</title>
    <link>https://qvqw.date/archives/2025/</link>
    <description>Recent content in 2025 on LLP2333&#39;s Blog</description>
    <image>
      <title>LLP2333&#39;s Blog</title>
      <url>https://qvqw.date/images/papermod-cover.png</url>
      <link>https://qvqw.date/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.115.4</generator>
    <language>en</language>
    <lastBuildDate>Wed, 08 Jan 2025 16:06:02 +0800</lastBuildDate>
    <atom:link href="https://qvqw.date/archives/2025/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java的ResourceBundle读取配置文件路径</title>
      <link>https://qvqw.date/posts/java%E7%9A%84resourcebundle%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 08 Jan 2025 16:06:02 +0800</pubDate>
      <guid>https://qvqw.date/posts/java%E7%9A%84resourcebundle%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</guid>
      <description>当你使用
// 1. 创建或加载 ResourceBundle ResourceBundle bundle = ResourceBundle.getBundle(&amp;#34;messages&amp;#34;); // 从 classpath 加载 messages.properties // 2. 使用getString()获取字符串值 String value = bundle.getString(&amp;#34;key.name&amp;#34;); 读取文件时 代码默认会读取src/main/resources/messages.properties
src/main/resources/messages.properties // 默认 src/main/resources/messages_zh.properties // 中文 src/main/resources/messages_en.properties // 英文 样例配置文件
key.name=值 welcome.message=欢迎 error.code=500 如果想指定读取的文件
// 指定英文 Locale Locale enLocale = new Locale(&amp;#34;en&amp;#34;); // 或者直接用 Locale.ENGLISH // 加载英文资源包 ResourceBundle bundle = ResourceBundle.getBundle(&amp;#34;messages&amp;#34;, enLocale); // 获取英文值 String value = bundle.getString(&amp;#34;key.name&amp;#34;); </description>
    </item>
    <item>
      <title>某云办公应用api存在IP白名单绕过风险</title>
      <link>https://qvqw.date/posts/%E6%9F%90%E4%BA%91%E5%8A%9E%E5%85%AC%E5%BA%94%E7%94%A8api%E5%AD%98%E5%9C%A8ip%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87%E9%A3%8E%E9%99%A9/</link>
      <pubDate>Wed, 08 Jan 2025 10:14:16 +0800</pubDate>
      <guid>https://qvqw.date/posts/%E6%9F%90%E4%BA%91%E5%8A%9E%E5%85%AC%E5%BA%94%E7%94%A8api%E5%AD%98%E5%9C%A8ip%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87%E9%A3%8E%E9%99%A9/</guid>
      <description>最近在做一个消息推送企业某信的需求，使用的不是官方的api,而是和企业某信可以集成的云办公平台的api。由于api有ip白名单限制，导致我必须在特定化网络环境下发请求，测试很麻烦，所以想测试一下能不能绕过限制。 想要绕过限制，首先要知道服务器如何获取发送者的ip。
服务器如何获取请求者ip 获取请求者 IP 本质上就两个来源：
直接从 IP 数据包获取 这就是 HttpServletRequest的getRemoteAddr() 的工作原理，获取的是直接与服务器建立 TCP 连接的客户端 IP，在没有代理的情况下,这就是真实的客户端 IP 从 HTTP 请求头获取 常见的请求头有: X-Forwarded-For X-Real-IP Proxy-Client-IP WL-Proxy-Client-IP 测试 这里我使用了postman伪造了请求头X-Forwarded-For，经过测试，理论上只要知道正确的ip，就可以让ip白名单功能失效。
如果你有服务器的访问权限，但是只知道服务器的内网ip，可以尝试
curl ifconfig.me 然后就能得到服务器的公网ip了
安全建议 改用网络层的源IP地址(TCP/IP报文中的source IP)进行验证
如果必须使用代理转发,建议只信任内部代理服务器传递的XFF头
吐槽 某云办公平台必须付费才能获得访问api的密钥，并且密钥只有一个，测试只能直接在正式系统测</description>
    </item>
    <item>
      <title>用go写了个简化hugo文章创建的小工具</title>
      <link>https://qvqw.date/posts/%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AA%E7%AE%80%E5%8C%96hugo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 07 Jan 2025 14:11:52 +0800</pubDate>
      <guid>https://qvqw.date/posts/%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AA%E7%AE%80%E5%8C%96hugo%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>目前使用hugo作为博客系统，使用typora作为博客的编辑器。书接上文Hugo使用技巧，之前每次都需要在博客根目录执行
hugo new posts/文章标题/index.md 创建新的文章。感觉很麻烦。所以想写个工具简化这个过程。
思路 输入文件标题后执行创建文章的命令，然后生成新的文章的快捷方式，方便使用typora进行编辑。
代码 使用Claude生成的，很方便。
如果是windows平台，使用
go build -o HugoHelper.exe main.go 进行编译。
使用前需要配置blog环境变量，key为blog,value为你的项目的根路径
比如我的根目录是C:\UGit\qvqw.date
代码
package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/exec&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;strings&amp;#34; ) func main() { // 获取当前程序执行路径 execPath, err := os.Getwd() if err != nil { fmt.Printf(&amp;#34;错误: 获取当前路径失败: %v\n&amp;#34;, err) os.Exit(1) } // 从环境变量获取博客路径 blogPath := os.Getenv(&amp;#34;blog&amp;#34;) if blogPath == &amp;#34;&amp;#34; { fmt.Println(&amp;#34;错误: 环境变量 &amp;#39;blog&amp;#39; 未设置&amp;#34;) os.Exit(1) } // 验证博客路径是否存在 if _, err := os.</description>
    </item>
  </channel>
</rss>
